<!-- -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------->


<!-- --------------------------------------------------------------------- PASAR PROYECTO VANILLA A REACT  -------------------------------------------------------------------------->
<!--
1-- creamos el proyecto con vite

  npm create vite@latest

2-- Seleccionamos VANILLA

3-- Seleccionamos JavaScript

4-- cd proyecto
  npm install @vitejs/plugin-react -E  (-E Esto garantiza que siempre se use exactamente esa versión, lo que puede ser útil para evitar problemas de compatibilidad o 
                                        diferencias inesperadas entre entornos. )

5-- instalar dependencias 
npm install react react-dom -E

6-- Creamos el archivo vite.config.js en la raiz del proyecto

vite.config.js :

import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()]
})

7-- Iniciar aplicacion con react en el punto de entrada ( main.js ) 

import { createRoot } from 'react-dom/client'

const root = createRoot(document.getElementById('app'))
root.render(<h1>Hello World</h1>)

8-- Cambiar la extension de main.js a jsx 
9-- Cambiar la extension de main.js a main.jsx en el index.html

-->

<!-- --------------------------------------------------------------------- HOOK  useState()  ESTADO  -------------------------------------------------------------------------------->


<!-- 
El useState en React es un hook que nos permite manejar el estado en componentes funcionales. En React, el estado es un objeto que almacena información dinámica que puede 
cambiar con el tiempo. Antes de los hooks, solo los componentes de clase podían manejar estado, pero con useState, podemos trabajar con él en componentes funcionales.


Declaración: Se utiliza dentro del componente para declarar una variable de estado y una función que permita actualizarla. La sintaxis básica es:

const [estado, setEstado] = useState(valorInicial);

estado: Es el valor actual del estado.
setEstado: Es una función para actualizar el valor de estado.
valorInicial: Es el valor con el que comienza el estado.

Cuando se llama a setEstado, React vuelve a renderizar el componente con el nuevo valor del estado.


EJEMPLO:


function Contador() {
  // Declaramos una variable de estado llamada 'contador', con un valor inicial de 0
  const [contador, setContador] = useState(0);

  // Función que incrementa el contador
  const incrementar = () => {
    setContador(contador + 1); // Actualizamos el estado
  };

  // Función que reinicia el contador a 0
  const reiniciar = () => {
    setContador(0); // Actualizamos el estado
  };

  return (
    <div>
      <h1>Contador: {contador}</h1>
      <button onClick={incrementar}>
        Incrementar
      </button>
      <button onClick={reiniciar}>
        Reiniciar
      </button>
    </div>
  );
}


-->

<!-- --------------------------------------------------------------------- HOOK  useEffect()    ----------------------------------------------------------------------------------->

<!-- 

El hook useEffect es una herramienta en React que permite manejar efectos secundarios en los componentes funcionales. 
Un efecto secundario es cualquier acción que interactúe con el mundo exterior de tu componente, como:

Llamadas a una API.
Actualización de datos.
Subscripciones a eventos.
Manipulación del DOM.


useEffect(() => {
  // Código del efecto principal
  return () => {
    // Código de limpieza opcional
  };
}, [dependencias]);


1 Efecto principal: Es el código que deseas ejecutar.
2 Limpieza opcional: Se ejecuta antes de que el efecto se vuelva a ejecutar o cuando el componente se desmonte.
3 Array de dependencias: Controla cuándo se ejecuta el efecto:
  -Si está vacío [], el efecto solo se ejecuta una vez, después del montaje.
  -Si tiene dependencias, el efecto se ejecuta cuando alguna de ellas cambia.
  -Si omites el array, el efecto se ejecuta después de cada renderizado (no recomendado en la mayoría de los casos).



const Timer = () => {
    const [seconds, setSeconds] = useState(0);

    useEffect(() => {
        const interval = setInterval(() => {
            setSeconds((prev) => prev + 1);
        }, 1000);

        return () => {
            clearInterval(interval); // Limpieza para evitar intervalos innecesarios
        };
    }, []); // Solo al montar y desmontar

    return <h1>Segundos: {seconds}</h1>;
};



-->

<!-- ---------------------------------------------------------------------    .MAP     ----------------------------------------------------------------------------------- -->

<!-- 

.map() es un método en JavaScript que se utiliza comúnmente con arreglos. Este método se llama en un arreglo y crea un nuevo arreglo con los resultados de llamar a una función 
proporcionada en cada elemento del arreglo original. Aquí tienes una explicación más detallada:

La sintaxis básica de .map() es la siguiente:


nuevoArreglo = arregloOriginal.map(funcionDeRetorno(elemento, indice, arreglo));


arregloOriginal: El arreglo en el cual se llama el método .map().

funcionDeRetorno: Una función que se ejecutará para cada elemento del arreglo. Recibe tres argumentos:

    elemento: El elemento actual que está siendo procesado.
    indice: El índice del elemento actual en el arreglo.
    arreglo: El arreglo sobre el cual se está iterando.

El método .map() devuelve un nuevo arreglo con los resultados de aplicar la función de retorno a cada elemento del arreglo original.



EJEMPLO:


const numeros = [1, 2, 3, 4, 5];

const duplicados = numeros.map((numero, indice) => {
  console.log(`Procesando elemento en el índice ${indice}`);
  return numero * 2;
});

console.log(duplicados);


Durante el recorrido del map, se imprimirán estos mensajes en la consola:

Procesando elemento en el índice 0
Procesando elemento en el índice 1
Procesando elemento en el índice 2
Procesando elemento en el índice 3
Procesando elemento en el índice 4

Después, se imprimirá el array duplicados:

[2, 4, 6, 8, 10]

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


-------------------------------------------------------------------------INSTALAR ESLINT STANDARD-------------------------------------------------------------------------------

- INSTALAR EXTENSION ESLINT
- INSTALAR STANDARD como dependencia de desarrollo
   npm install standard -D

-AGREGAR A package.json para que tenga en cuenta las reglas de standard

  "eslintConfig": {
    "extends": "./node_modules/standard/eslintrc.json"
  }

-AGREGAR A SETTINGS.JSON para que formatee el codigo al guardar
"editor.formatOnSave": true,
"eslint.codeActionsOnSave.rules": null


-->